function signal_trans = transmitter(bits, num_frame, fh_pat_lib, th_pat_lib, pn_lib_S1, pn_lib_S2, pn_lib_S3, pn_lib_S4, mode)

% 载入参数
load('lib/f_trans.mat');  % 21个频点
load('lib/g_1024.mat');  % GMSK调制 g函数 
g = g(1:16:end);

% 基本参数定义
bit_rate = 16e6; % 符号速率
T = 1/bit_rate;  % 符号时间
fs_IF = 1024e6;  % 中频信号采样速率
fs_BB = 64e6;    % 基带信号采样速率
oversamp_IF = T * fs_IF;
oversamp_BB = T * fs_BB;
num_bits_pn = 24;  % 同步头S1\S2 长度
num_bits_pn_2 = 21;  % 同步头S3\S4 长度

switch mode
    % 2Mbps A 模式
    case 1 
        num_pulses = 12;
        % 同步头序列
        pn = [1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; % 2Mbps A 模式同步头S1\S2对应的扰码序列
        S1_lib = zeros(num_pulses, num_bits_pn);
        S2_lib = zeros(num_pulses, num_bits_pn);

        for i = 1:num_pulses
            S1_lib(i,:) = double(xor(pn_lib_S1(fh_pat_lib(i),:), pn));    %跳频图案映射
            S2_lib(i,:) = double(xor(pn_lib_S2(fh_pat_lib(i),:), pn));
        end
        
        % 跳频图案
        fh_pat = fh_pat_lib(1:num_pulses);
        % 跳时图案
        th_pat = th_pat_lib(1:num_pulses);

        last = 0;
        for i = 1:num_frame*num_pulses
            % 调制参数初始化
            % 初相、中频频率、同步头序列、跳时长度
            f_idx = fh_pat(mod(i-1,12)+1);
            f_IF = f_trans(f_idx);
            % 预编码
            bit_data = 2*precode(bits(1+(i-1)*256:i*256))-1;
            preamble_S1 = 2*(S1_lib(mod(i-1,12)+1,:))-1;
            preamble_S2 = 2*(S2_lib(mod(i-1,12)+1,:))-1;

            [GMSK_S1, ~] = GMSK_mode(preamble_S1, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_data, ~] = GMSK_mode(bit_data, size(bit_data, 2), oversamp_BB, 0, g);
            [GMSK_S2, ~] = GMSK_mode(preamble_S2, num_bits_pn, oversamp_BB, 0, g);

            signal_trans_BB = [GMSK_S1, GMSK_data, GMSK_S2];
            % 插值64->256
            signal_trans_BB_256 = zeros(1, size(signal_trans_BB, 2)*4);
            signal_trans_BB_256(1:4:end) = signal_trans_BB;
            % 滤波LPF 15 ~ 30 64阶
            LPF_oversamp1 = [-0.000403967603433978,-0.000470021169172027,-0.000494172380954801,-0.000258652061717940,0.000283008919773449,0.00104342881674853,0.00177877766576308,0.00213331724590840,0.00175762372268085,0.000472111989861735,-0.00158164555468341,-0.00387561801376341,-0.00557237563305645,-0.00576127353702420,-0.00380499886330475,0.000311000511441798,0.00576693418661190,0.0109549868338650,0.0138413858478660,0.0125917351430066,0.00630086859158115,-0.00440805649564046,-0.0171467743959188,-0.0280504836608703,-0.0325938485551124,-0.0267738099074316,-0.00835136327286768,0.0222180243701689,0.0614775971066216,0.103448080226734,0.140826316561104,0.166626189437254,0.175833184442315,0.166626189437254,0.140826316561104,0.103448080226734,0.0614775971066216,0.0222180243701689,-0.00835136327286768,-0.0267738099074316,-0.0325938485551124,-0.0280504836608703,-0.0171467743959188,-0.00440805649564046,0.00630086859158115,0.0125917351430066,0.0138413858478660,0.0109549868338650,0.00576693418661190,0.000311000511441798,-0.00380499886330475,-0.00576127353702420,-0.00557237563305645,-0.00387561801376341,-0.00158164555468341,0.000472111989861735,0.00175762372268085,0.00213331724590840,0.00177877766576308,0.00104342881674853,0.000283008919773449,-0.000258652061717940,-0.000494172380954801,-0.000470021169172027,-0.000403967603433978];
            signal_trans_BB_256_tmp = conv(signal_trans_BB_256, LPF_oversamp1);
            signal_trans_BB_256_cpl = signal_trans_BB_256_tmp(32+1:32+length(signal_trans_BB_256));
            % 插值256->1024
            signal_trans_BB_1024 = zeros(1, size(signal_trans_BB_256_cpl, 2)*4);
            signal_trans_BB_1024(1:4:end) = signal_trans_BB_256_cpl;
            % 滤波LPF 50 ~ 100 64阶
            LPF_oversamp2 = [0.000928483461724443,0.00101897000342884,0.00111941512765490,0.00109134955221668,0.000513110751321802,-0.000329263317840889,-0.00161737977457916,-0.00281851396393338,-0.00384497748110981,-0.00403752406335235,-0.00332605412123115,-0.00132812502615303,0.00156655957801075,0.00511046042846265,0.00830833019347255,0.0104451489819032,0.0104122837708622,0.00780472130899900,0.00232081948506836,-0.00526829344153218,-0.0138784658853216,-0.0214607092345050,-0.0260346918898819,-0.0253359567192890,-0.0179833982496921,-0.00314871957655408,0.0184734625187072,0.0453092008927343,0.0743837323574037,0.102399547276803,0.125590495797623,0.140998149290966,0.146329253655510,0.140998149290966,0.125590495797623,0.102399547276803,0.0743837323574037,0.0453092008927343,0.0184734625187072,-0.00314871957655408,-0.0179833982496921,-0.0253359567192890,-0.0260346918898819,-0.0214607092345050,-0.0138784658853216,-0.00526829344153218,0.00232081948506836,0.00780472130899900,0.0104122837708622,0.0104451489819032,0.00830833019347255,0.00511046042846265,0.00156655957801075,-0.00132812502615303,-0.00332605412123115,-0.00403752406335235,-0.00384497748110981,-0.00281851396393338,-0.00161737977457916,-0.000329263317840889,0.000513110751321802,0.00109134955221668,0.00111941512765490,0.00101897000342884,0.000928483461724443];
            signal_trans_BB_1024_tmp = conv(signal_trans_BB_1024, LPF_oversamp2);
            signal_trans_BB_1024_cpl = signal_trans_BB_1024_tmp(32+1:32+length(signal_trans_BB_1024));
            t = linspace(0, 304*T, size(signal_trans_BB_1024_cpl,2));
            signal_trans_IF = signal_trans_BB_1024_cpl .* exp(1i*2*pi*f_IF*t);
            % 将各帧调制后的信号波形按照跳时图案组成连续的信号波形
            th = th_pat(mod(i-1,12)+1);
            temp_S = [zeros(1, th/2*oversamp_IF), signal_trans_IF, zeros(1, th/2*oversamp_IF), zeros(1,103*oversamp_IF)];
            signal_trans(last+1:last+length(temp_S)) = temp_S;
            last = last+length(temp_S);
        end
        
    % 2Mbps B 模式
    case 2
        
        num_pulses = 12;
        signal_BB_out=zeros(12,(304+103+5120)*64);
        % 同步头序列
        pn = [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0];  % 2Mbps B 模式同步头S1\S2对应的扰码序列
        
        S1_lib = zeros(1, num_bits_pn);
        S2_lib = zeros(1, num_bits_pn);

        for i = 1:num_pulses
            S1_lib(i,:) = double(xor(pn_lib_S1(fh_pat_lib(i),:), pn));    %跳频图案映射
            S2_lib(i,:) = double(xor(pn_lib_S2(fh_pat_lib(i),:), pn));
        end
        
        % 跳频图案
        fh_pat = fh_pat_lib(1:num_pulses);
        % 跳时图案
        th_pat = th_pat_lib(1:num_pulses);
        
        frame_last_bit = 0;
        last = 0;
        for i = 1:num_frame*num_pulses
            % 调制参数初始化
            % 初相、中频频率、同步头序列、跳时长度
            f_idx = fh_pat(mod(i-1,12)+1);
            f_IF = f_trans(f_idx);
            preamble_S1 = 2*(S1_lib(mod(i-1,12)+1,:))-1;
            preamble_S2 = 2*(S2_lib(mod(i-1,12)+1,:))-1;
            th = th_pat(mod(i-1,12)+1);
            bit_data_0 = 2*precode(bits(frame_last_bit+1:frame_last_bit+th/2))-1;
            bit_data_1 = 2*precode(bits(frame_last_bit+th/2+1:frame_last_bit+th/2+256))-1;
            bit_data_2 = 2*precode(bits(frame_last_bit+th/2+257:frame_last_bit+th/2+256+th/2))-1;

            [GMSK_data_0, ~] = GMSK_mode(bit_data_0, size(bit_data_0, 2), oversamp_BB, 0, g);
            [GMSK_S1, ~] = GMSK_mode(preamble_S1, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_data_1, ~] = GMSK_mode(bit_data_1, size(bit_data_1, 2), oversamp_BB, 0, g);
            [GMSK_S2, ~] = GMSK_mode(preamble_S2, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_data_2, ~] = GMSK_mode(bit_data_2, size(bit_data_2, 2), oversamp_BB, 0, g);

            frame_last_bit = frame_last_bit + 256 + th;

            signal_trans_BB = [GMSK_data_0, GMSK_S1, GMSK_data_1, GMSK_S2, GMSK_data_2];
            % 插值64->256
            signal_trans_BB_256 = zeros(1, size(signal_trans_BB, 2)*4);
            signal_trans_BB_256(1:4:end) = signal_trans_BB;
            % 滤波LPF 15 ~ 30 64阶
            LPF_oversamp1 = [-0.000403967603433978,-0.000470021169172027,-0.000494172380954801,-0.000258652061717940,0.000283008919773449,0.00104342881674853,0.00177877766576308,0.00213331724590840,0.00175762372268085,0.000472111989861735,-0.00158164555468341,-0.00387561801376341,-0.00557237563305645,-0.00576127353702420,-0.00380499886330475,0.000311000511441798,0.00576693418661190,0.0109549868338650,0.0138413858478660,0.0125917351430066,0.00630086859158115,-0.00440805649564046,-0.0171467743959188,-0.0280504836608703,-0.0325938485551124,-0.0267738099074316,-0.00835136327286768,0.0222180243701689,0.0614775971066216,0.103448080226734,0.140826316561104,0.166626189437254,0.175833184442315,0.166626189437254,0.140826316561104,0.103448080226734,0.0614775971066216,0.0222180243701689,-0.00835136327286768,-0.0267738099074316,-0.0325938485551124,-0.0280504836608703,-0.0171467743959188,-0.00440805649564046,0.00630086859158115,0.0125917351430066,0.0138413858478660,0.0109549868338650,0.00576693418661190,0.000311000511441798,-0.00380499886330475,-0.00576127353702420,-0.00557237563305645,-0.00387561801376341,-0.00158164555468341,0.000472111989861735,0.00175762372268085,0.00213331724590840,0.00177877766576308,0.00104342881674853,0.000283008919773449,-0.000258652061717940,-0.000494172380954801,-0.000470021169172027,-0.000403967603433978];
            signal_trans_BB_256_tmp = conv(signal_trans_BB_256, LPF_oversamp1);
            signal_trans_BB_256_cpl = signal_trans_BB_256_tmp(32+1:32+length(signal_trans_BB_256));
            % 插值256->1024
            signal_trans_BB_1024 = zeros(1, size(signal_trans_BB_256_cpl, 2)*4);
            signal_trans_BB_1024(1:4:end) = signal_trans_BB_256_cpl;
            % 滤波LPF 50 ~ 100 64阶
            LPF_oversamp2 = [0.000928483461724443,0.00101897000342884,0.00111941512765490,0.00109134955221668,0.000513110751321802,-0.000329263317840889,-0.00161737977457916,-0.00281851396393338,-0.00384497748110981,-0.00403752406335235,-0.00332605412123115,-0.00132812502615303,0.00156655957801075,0.00511046042846265,0.00830833019347255,0.0104451489819032,0.0104122837708622,0.00780472130899900,0.00232081948506836,-0.00526829344153218,-0.0138784658853216,-0.0214607092345050,-0.0260346918898819,-0.0253359567192890,-0.0179833982496921,-0.00314871957655408,0.0184734625187072,0.0453092008927343,0.0743837323574037,0.102399547276803,0.125590495797623,0.140998149290966,0.146329253655510,0.140998149290966,0.125590495797623,0.102399547276803,0.0743837323574037,0.0453092008927343,0.0184734625187072,-0.00314871957655408,-0.0179833982496921,-0.0253359567192890,-0.0260346918898819,-0.0214607092345050,-0.0138784658853216,-0.00526829344153218,0.00232081948506836,0.00780472130899900,0.0104122837708622,0.0104451489819032,0.00830833019347255,0.00511046042846265,0.00156655957801075,-0.00132812502615303,-0.00332605412123115,-0.00403752406335235,-0.00384497748110981,-0.00281851396393338,-0.00161737977457916,-0.000329263317840889,0.000513110751321802,0.00109134955221668,0.00111941512765490,0.00101897000342884,0.000928483461724443];
            signal_trans_BB_1024_tmp = conv(signal_trans_BB_1024, LPF_oversamp2);
            signal_trans_BB_1024_cpl = signal_trans_BB_1024_tmp(32+1:32+length(signal_trans_BB_1024));
            t = linspace(0, (304+th)*T, size(signal_trans_BB_1024_cpl,2));
            signal_trans_IF = signal_trans_BB_1024_cpl .* exp(1i*2*pi*f_IF*t);
                
            temp = [signal_trans_IF, zeros(1, 103*oversamp_IF)];
            signal_trans(last+1:last+(103+304+th)*oversamp_IF) = temp;
            last = last + (103+304+th)*oversamp_IF;
        end
        
    % 500K 模式    
    case 3
        
        num_pulses = 48;
        
        % 同步头序列
        pn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];  % 500Kbps 模式 同步头S1\S2对应的扰码序列
        pn_2 = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];  % 500Kbps 模式 同步头S3\S4对应的扰码序列
        S1_lib = zeros(num_pulses, num_bits_pn);
        S2_lib = zeros(num_pulses, num_bits_pn);
        S3_lib = zeros(num_pulses, num_bits_pn_2);
        S4_lib = zeros(num_pulses, num_bits_pn_2);

        for i = 1:num_pulses
            S1_lib(i,:) = double(xor(pn_lib_S1(fh_pat_lib(i),:), pn));    %跳频图案映射
            S2_lib(i,:) = double(xor(pn_lib_S2(fh_pat_lib(i),:), pn));
            S3_lib(i,:) = double(xor(pn_lib_S3(fh_pat_lib(i),:), pn_2));
            S4_lib(i,:) = double(xor(pn_lib_S4(fh_pat_lib(i),:), pn_2));
        end
        
        % 跳频图案
        fh_pat = fh_pat_lib(1:num_pulses);
        % 跳时图案
        th_pat = th_pat_lib(1:num_pulses);
        
        last = 0;
        frame_last_bit = 0;
        for i = 1:num_frame*num_pulses
            % 调制参数初始化
            % 初相、中频频率、同步头序列、跳时长度
            f_idx = fh_pat(mod(i-1,48)+1);
            f_IF = f_trans(f_idx);
            % 预编码

            if mod(i, 48) == 0
                bit_data = 2*precode([bits(1+frame_last_bit:182+frame_last_bit), zeros(1, 32)])-1;
                frame_last_bit = frame_last_bit + 182;
            else
                bit_data = 2*precode(bits(1+frame_last_bit:214+frame_last_bit))-1;
                frame_last_bit = frame_last_bit + 214;
            end

            preamble_S1 = 2*(S1_lib(mod(i-1,48)+1,:))-1;
            preamble_S2 = 2*(S2_lib(mod(i-1,48)+1,:))-1;
            preamble_S3 = 2*(S3_lib(mod(i-1,48)+1,:))-1;
            preamble_S4 = 2*(S4_lib(mod(i-1,48)+1,:))-1;            

            [GMSK_S1, ~] = GMSK_mode(preamble_S1, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_S2, ~] = GMSK_mode(preamble_S2, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_S3, ~] = GMSK_mode(preamble_S3, num_bits_pn_2, oversamp_BB, 0, g);
            [GMSK_S4, ~] = GMSK_mode(preamble_S4, num_bits_pn_2, oversamp_BB, 0, g);
            [GMSK_data, ~] = GMSK_mode(bit_data, size(bit_data, 2), oversamp_BB, 0, g);

            signal_trans_BB = [GMSK_S1, GMSK_S3, GMSK_data, GMSK_S4, GMSK_S2];
            % 插值64->256
            signal_trans_BB_256 = zeros(1, size(signal_trans_BB, 2)*4);
            signal_trans_BB_256(1:4:end) = signal_trans_BB;
            % 滤波LPF 15 ~ 30 64阶
            LPF_oversamp1 = [-0.000403967603433978,-0.000470021169172027,-0.000494172380954801,-0.000258652061717940,0.000283008919773449,0.00104342881674853,0.00177877766576308,0.00213331724590840,0.00175762372268085,0.000472111989861735,-0.00158164555468341,-0.00387561801376341,-0.00557237563305645,-0.00576127353702420,-0.00380499886330475,0.000311000511441798,0.00576693418661190,0.0109549868338650,0.0138413858478660,0.0125917351430066,0.00630086859158115,-0.00440805649564046,-0.0171467743959188,-0.0280504836608703,-0.0325938485551124,-0.0267738099074316,-0.00835136327286768,0.0222180243701689,0.0614775971066216,0.103448080226734,0.140826316561104,0.166626189437254,0.175833184442315,0.166626189437254,0.140826316561104,0.103448080226734,0.0614775971066216,0.0222180243701689,-0.00835136327286768,-0.0267738099074316,-0.0325938485551124,-0.0280504836608703,-0.0171467743959188,-0.00440805649564046,0.00630086859158115,0.0125917351430066,0.0138413858478660,0.0109549868338650,0.00576693418661190,0.000311000511441798,-0.00380499886330475,-0.00576127353702420,-0.00557237563305645,-0.00387561801376341,-0.00158164555468341,0.000472111989861735,0.00175762372268085,0.00213331724590840,0.00177877766576308,0.00104342881674853,0.000283008919773449,-0.000258652061717940,-0.000494172380954801,-0.000470021169172027,-0.000403967603433978];
            signal_trans_BB_256_tmp = conv(signal_trans_BB_256, LPF_oversamp1);
            signal_trans_BB_256_cpl = signal_trans_BB_256_tmp(32+1:32+length(signal_trans_BB_256));
            % 插值256->1024
            signal_trans_BB_1024 = zeros(1, size(signal_trans_BB_256_cpl, 2)*4);
            signal_trans_BB_1024(1:4:end) = signal_trans_BB_256_cpl;
            % 滤波LPF 50 ~ 100 64阶
            LPF_oversamp2 = [0.000928483461724443,0.00101897000342884,0.00111941512765490,0.00109134955221668,0.000513110751321802,-0.000329263317840889,-0.00161737977457916,-0.00281851396393338,-0.00384497748110981,-0.00403752406335235,-0.00332605412123115,-0.00132812502615303,0.00156655957801075,0.00511046042846265,0.00830833019347255,0.0104451489819032,0.0104122837708622,0.00780472130899900,0.00232081948506836,-0.00526829344153218,-0.0138784658853216,-0.0214607092345050,-0.0260346918898819,-0.0253359567192890,-0.0179833982496921,-0.00314871957655408,0.0184734625187072,0.0453092008927343,0.0743837323574037,0.102399547276803,0.125590495797623,0.140998149290966,0.146329253655510,0.140998149290966,0.125590495797623,0.102399547276803,0.0743837323574037,0.0453092008927343,0.0184734625187072,-0.00314871957655408,-0.0179833982496921,-0.0253359567192890,-0.0260346918898819,-0.0214607092345050,-0.0138784658853216,-0.00526829344153218,0.00232081948506836,0.00780472130899900,0.0104122837708622,0.0104451489819032,0.00830833019347255,0.00511046042846265,0.00156655957801075,-0.00132812502615303,-0.00332605412123115,-0.00403752406335235,-0.00384497748110981,-0.00281851396393338,-0.00161737977457916,-0.000329263317840889,0.000513110751321802,0.00109134955221668,0.00111941512765490,0.00101897000342884,0.000928483461724443];
            signal_trans_BB_1024_tmp = conv(signal_trans_BB_1024, LPF_oversamp2);
            signal_trans_BB_1024_cpl = signal_trans_BB_1024_tmp(32+1:32+length(signal_trans_BB_1024));
            t = linspace(0, 304*T, size(signal_trans_BB_1024_cpl,2));
            signal_trans_IF = signal_trans_BB_1024_cpl .* exp(1i*2*pi*f_IF*t);
            % 将各帧调制后的信号波形按照跳时图案组成连续的信号波形
            th = th_pat(mod(i-1,48)+1);
            temp_S = [zeros(1, th/2*oversamp_IF), signal_trans_IF, zeros(1, th/2*oversamp_IF), zeros(1,103*oversamp_IF)];
            signal_trans(last+1:last+length(temp_S)) = temp_S;
            last = last+length(temp_S);
        end
        
    % 250K 模式 
    case 4
        
        num_pulses = 96;
        
        % 同步头序列
        pn = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];  % 250Kbps 模式 同步头S1\S2对应的扰码序列
        pn_2 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];  % 250Kbps 模式 同步头S3\S4对应的扰码序列
        S1_lib = zeros(num_pulses, num_bits_pn);
        S2_lib = zeros(num_pulses, num_bits_pn);
        S3_lib = zeros(num_pulses, num_bits_pn_2);
        S4_lib = zeros(num_pulses, num_bits_pn_2);

        for i = 1:num_pulses
            S1_lib(i,:) = double(xor(pn_lib_S1(fh_pat_lib(i),:), pn));    %跳频图案映射
            S2_lib(i,:) = double(xor(pn_lib_S2(fh_pat_lib(i),:), pn));
            S3_lib(i,:) = double(xor(pn_lib_S3(fh_pat_lib(i),:), pn_2));
            S4_lib(i,:) = double(xor(pn_lib_S4(fh_pat_lib(i),:), pn_2));
        end
        
        % 跳频图案
        fh_pat = fh_pat_lib(1:num_pulses);
        % 跳时图案
        th_pat = th_pat_lib(1:num_pulses);
        
        last = 0;
        frame_last_bit = 0;
        for i = 1:num_frame*num_pulses
            % 调制参数初始化
            % 初相、中频频率、同步头序列、跳时长度
            f_idx = fh_pat(mod(i-1,num_pulses)+1);
            f_IF = f_trans(f_idx);
            % 预编码

            if mod(i, 48) == 0
                bit_data = 2*precode([bits(1+frame_last_bit:182+frame_last_bit), zeros(1, 32)])-1;
                frame_last_bit = frame_last_bit + 182;
            else
                bit_data = 2*precode(bits(1+frame_last_bit:214+frame_last_bit))-1;
                frame_last_bit = frame_last_bit + 214;
            end

            preamble_S1 = 2*(S1_lib(mod(i-1,48)+1,:))-1;
            preamble_S2 = 2*(S2_lib(mod(i-1,48)+1,:))-1;
            preamble_S3 = 2*(S3_lib(mod(i-1,48)+1,:))-1;
            preamble_S4 = 2*(S4_lib(mod(i-1,48)+1,:))-1;            

            [GMSK_S1, ~] = GMSK_mode(preamble_S1, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_S2, ~] = GMSK_mode(preamble_S2, num_bits_pn, oversamp_BB, 0, g);
            [GMSK_S3, ~] = GMSK_mode(preamble_S3, num_bits_pn_2, oversamp_BB, 0, g);
            [GMSK_S4, ~] = GMSK_mode(preamble_S4, num_bits_pn_2, oversamp_BB, 0, g);
            [GMSK_data, ~] = GMSK_mode(bit_data, size(bit_data, 2), oversamp_BB, 0, g);

            signal_trans_BB = [GMSK_S1, GMSK_S3, GMSK_data, GMSK_S4, GMSK_S2];
            % 插值64->256
            signal_trans_BB_256 = zeros(1, size(signal_trans_BB, 2)*4);
            signal_trans_BB_256(1:4:end) = signal_trans_BB;
            % 滤波LPF 15 ~ 30 64阶
            LPF_oversamp1 = [-0.000403967603433978,-0.000470021169172027,-0.000494172380954801,-0.000258652061717940,0.000283008919773449,0.00104342881674853,0.00177877766576308,0.00213331724590840,0.00175762372268085,0.000472111989861735,-0.00158164555468341,-0.00387561801376341,-0.00557237563305645,-0.00576127353702420,-0.00380499886330475,0.000311000511441798,0.00576693418661190,0.0109549868338650,0.0138413858478660,0.0125917351430066,0.00630086859158115,-0.00440805649564046,-0.0171467743959188,-0.0280504836608703,-0.0325938485551124,-0.0267738099074316,-0.00835136327286768,0.0222180243701689,0.0614775971066216,0.103448080226734,0.140826316561104,0.166626189437254,0.175833184442315,0.166626189437254,0.140826316561104,0.103448080226734,0.0614775971066216,0.0222180243701689,-0.00835136327286768,-0.0267738099074316,-0.0325938485551124,-0.0280504836608703,-0.0171467743959188,-0.00440805649564046,0.00630086859158115,0.0125917351430066,0.0138413858478660,0.0109549868338650,0.00576693418661190,0.000311000511441798,-0.00380499886330475,-0.00576127353702420,-0.00557237563305645,-0.00387561801376341,-0.00158164555468341,0.000472111989861735,0.00175762372268085,0.00213331724590840,0.00177877766576308,0.00104342881674853,0.000283008919773449,-0.000258652061717940,-0.000494172380954801,-0.000470021169172027,-0.000403967603433978];
            signal_trans_BB_256_tmp = conv(signal_trans_BB_256, LPF_oversamp1);
            signal_trans_BB_256_cpl = signal_trans_BB_256_tmp(32+1:32+length(signal_trans_BB_256));
            % 插值256->1024
            signal_trans_BB_1024 = zeros(1, size(signal_trans_BB_256_cpl, 2)*4);
            signal_trans_BB_1024(1:4:end) = signal_trans_BB_256_cpl;
            % 滤波LPF 50 ~ 100 64阶
            LPF_oversamp2 = [0.000928483461724443,0.00101897000342884,0.00111941512765490,0.00109134955221668,0.000513110751321802,-0.000329263317840889,-0.00161737977457916,-0.00281851396393338,-0.00384497748110981,-0.00403752406335235,-0.00332605412123115,-0.00132812502615303,0.00156655957801075,0.00511046042846265,0.00830833019347255,0.0104451489819032,0.0104122837708622,0.00780472130899900,0.00232081948506836,-0.00526829344153218,-0.0138784658853216,-0.0214607092345050,-0.0260346918898819,-0.0253359567192890,-0.0179833982496921,-0.00314871957655408,0.0184734625187072,0.0453092008927343,0.0743837323574037,0.102399547276803,0.125590495797623,0.140998149290966,0.146329253655510,0.140998149290966,0.125590495797623,0.102399547276803,0.0743837323574037,0.0453092008927343,0.0184734625187072,-0.00314871957655408,-0.0179833982496921,-0.0253359567192890,-0.0260346918898819,-0.0214607092345050,-0.0138784658853216,-0.00526829344153218,0.00232081948506836,0.00780472130899900,0.0104122837708622,0.0104451489819032,0.00830833019347255,0.00511046042846265,0.00156655957801075,-0.00132812502615303,-0.00332605412123115,-0.00403752406335235,-0.00384497748110981,-0.00281851396393338,-0.00161737977457916,-0.000329263317840889,0.000513110751321802,0.00109134955221668,0.00111941512765490,0.00101897000342884,0.000928483461724443];
            signal_trans_BB_1024_tmp = conv(signal_trans_BB_1024, LPF_oversamp2);
            signal_trans_BB_1024_cpl = signal_trans_BB_1024_tmp(32+1:32+length(signal_trans_BB_1024));
            t = linspace(0, 304*T, size(signal_trans_BB_1024_cpl,2));
            signal_trans_IF = signal_trans_BB_1024_cpl .* exp(1i*2*pi*f_IF*t);
            % 将各帧调制后的信号波形按照跳时图案组成连续的信号波形
            th = th_pat(mod(i-1,num_pulses)+1);
            temp_S = [zeros(1, th/2*oversamp_IF), signal_trans_IF, zeros(1, th/2*oversamp_IF), zeros(1,103*oversamp_IF)];
            signal_trans(last+1:last+length(temp_S)) = temp_S;
            last = last+length(temp_S);
        end
end